#include "MicroBit.h"

InterruptIn resetButton(MICROBIT_PIN_BUTTON_RESET);
MicroBitStorage storage;
MicroBitI2C i2c(I2C_SDA0, I2C_SCL0);
MicroBitMessageBus messageBus;
MicroBitDisplay display;
MicroBitButton buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);
MicroBitButton buttonB(MICROBIT_PIN_BUTTON_B, MICROBIT_ID_BUTTON_B);
MicroBitMultiButton buttonAB(MICROBIT_ID_BUTTON_A, MICROBIT_ID_BUTTON_B, MICROBIT_ID_BUTTON_AB);
MicroBitAccelerometer accelerometer(i2c);
MicroBitThermometer thermometer(storage);
MicroBitIO io(MICROBIT_ID_IO_P0, MICROBIT_ID_IO_P1, MICROBIT_ID_IO_P2,
              MICROBIT_ID_IO_P3, MICROBIT_ID_IO_P4, MICROBIT_ID_IO_P5,
              MICROBIT_ID_IO_P6, MICROBIT_ID_IO_P7, MICROBIT_ID_IO_P8,
              MICROBIT_ID_IO_P9, MICROBIT_ID_IO_P10, MICROBIT_ID_IO_P11,
              MICROBIT_ID_IO_P12, MICROBIT_ID_IO_P13, MICROBIT_ID_IO_P14,
              MICROBIT_ID_IO_P15, MICROBIT_ID_IO_P16, MICROBIT_ID_IO_P19,
              MICROBIT_ID_IO_P20);
MicroBitBLEManager bleManager(storage);
BLEDevice *ble;

/**
  * Will reset the micro:bit when called.
  */
void reset()
{
    if(ble && ble->getGapState().connected) {

        // We have a connected BLE peer. Disconnect the BLE session.
        ble->gap().disconnect(Gap::REMOTE_USER_TERMINATED_CONNECTION);

        // Wait a little while for the connection to drop.
        wait_ms(100);
    }

    microbit_reset();
}

/**
  * A listener to perform actions as a result of Message Bus reflection.
  *
  * In some cases we want to perform lazy instantiation of components, such as
  * the compass and the accelerometer, where we only want to add them to the idle
  * fiber when someone has the intention of using these components.
  */
void onListenerRegisteredEvent(MicroBitEvent evt)
{
    switch (evt.value)
    {
    case MICROBIT_ID_BUTTON_AB:
        // A user has registered to receive events from the buttonAB multibutton.
        // Disable click events from being generated by ButtonA and ButtonB, and defer the
        // control of this to the multibutton handler.
        //
        // This way, buttons look independent unless a buttonAB is requested, at which
        // point button A+B clicks can be correclty handled without breaking
        // causal ordering.
        buttonA.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);
        buttonB.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);
        buttonAB.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS);
        break;

    case MICROBIT_ID_ACCELEROMETER:
    case MICROBIT_ID_GESTURE:
        // A listener has been registered for the accelerometer.
        // The accelerometer uses lazy instantiation, we just need to read the data once to start it running.
        accelerometer.updateSample();
        break;

    case MICROBIT_ID_THERMOMETER:
        // A listener has been registered for the thermometer.
        // The thermometer uses lazy instantiation, we just need to read the data once to start it running.
        thermometer.updateSample();
        break;
    }
}

int main()
{
    // Bring up soft reset functionality as soon as possible.
    resetButton.mode(PullUp);
    resetButton.fall(reset);

    // Bring up a nested heap allocator.
    microbit_create_nested_heap(MICROBIT_NESTED_HEAP_SIZE);

    // Bring up fiber scheduler.
    scheduler_init(messageBus);

    // Seed our random number generator
    microbit_seed_random();

    // Create an event handler to trap any handlers being created for I2C services.
    // We do this to enable initialisation of those services only when they're used,
    // which saves processor time, memeory and battery life.
    messageBus.listen(MICROBIT_ID_MESSAGE_BUS_LISTENER, MICROBIT_EVT_ANY, onListenerRegisteredEvent);

    // Attempt to bring up a second heap region, using unused memory normally reserved for Soft Device.
    microbit_create_heap(MICROBIT_SD_GATT_TABLE_START + MICROBIT_SD_GATT_TABLE_SIZE, MICROBIT_SD_LIMIT);

    // Start the BLE stack, if it isn't already running.
    if (!ble)
    {
        bleManager.init("16025", "", messageBus, false);
        ble = bleManager.ble;
    }

    // Bring up BLE services
    new MicroBitLEDService(*ble, display);
    new MicroBitTemperatureService(*ble, thermometer);
    new MicroBitAccelerometerService(*ble, accelerometer);
    new MicroBitButtonService(*ble);
    new MicroBitIOPinService(*ble, io);

    while (true) {
        // Continually scroll text across the LED display
        display.scroll("Hello world!");
    }

    // If main exits, there may still be other fibers running or registered event handlers etc.
    // Simply release this fiber, which will mean we enter the scheduler. Worse case, we then
    // sit in the idle task forever, in a power efficient sleep.
    release_fiber();
}
